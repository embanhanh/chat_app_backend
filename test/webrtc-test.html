<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <title>Test WebRTC Video Call</title>
    <style>
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .auth-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .auth-form {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
        }
        .form-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .video-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        video {
            width: 400px;
            height: 300px;
            border: 1px solid #ccc;
            border-radius: 8px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
        }
        button:disabled {
            background-color: #ccc;
        }
        button.end-call {
            background-color: #dc3545;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            background-color: #f8f9fa;
        }
        #targetUserId {
            padding: 8px;
            margin-right: 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        .modal-content {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            min-width: 300px;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        .accept-call {
            background-color: #28a745 !important;
        }
        .reject-call {
            background-color: #dc3545 !important;
        }
        .calling-status {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Test WebRTC Video Call</h1>
        
        <div class="auth-container">
            <!-- Form ƒëƒÉng nh·∫≠p -->
            <div class="auth-form" id="loginForm">
                <h2>ƒêƒÉng nh·∫≠p</h2>
                <div class="form-group">
                    <label for="loginUsername">Username</label>
                    <input type="text" id="loginUsername" required>
                </div>
                <div class="form-group">
                    <label for="loginPassword">Password</label>
                    <input type="password" id="loginPassword" required>
                </div>
                <button onclick="login()">ƒêƒÉng nh·∫≠p</button>
            </div>

            <!-- Form ƒëƒÉng k√Ω -->
            <div class="auth-form" id="registerForm">
                <h2>ƒêƒÉng k√Ω</h2>
                <div class="form-group">
                    <label for="regUsername">Username</label>
                    <input type="text" id="regUsername" required>
                </div>
                <div class="form-group">
                    <label for="regEmail">Email</label>
                    <input type="email" id="regEmail" required>
                </div>
                <div class="form-group">
                    <label for="regPassword">Password</label>
                    <input type="password" id="regPassword" required>
                </div>
                <button onclick="register()">ƒêƒÉng k√Ω</button>
            </div>
        </div>

        <div class="call-section" style="display: none;">
            <div class="status" id="connectionStatus">Ch∆∞a k·∫øt n·ªëi</div>
            
            <div class="video-container">
                <div>
                    <h3>Local Video</h3>
                    <video id="localVideo" autoplay playsinline muted></video>
                </div>
                <div>
                    <h3>Remote Video</h3>
                    <video id="remoteVideo" autoplay playsinline></video>
                </div>
            </div>

            <div class="controls">
                <input type="text" id="targetUserId" placeholder="ID ng∆∞·ªùi nh·∫≠n">
                <button onclick="startCall()">G·ªçi</button>
                <button onclick="endCall()" class="end-call">K·∫øt th√∫c</button>
                <button onclick="toggleAudio()" id="audioBtn">T·∫Øt mic</button>
                <button onclick="toggleVideo()" id="videoBtn">T·∫Øt camera</button>
                <button onclick="logout()" class="end-call">ƒêƒÉng xu·∫•t</button>
            </div>
        </div>
    </div>

    <div id="incomingCallModal" class="modal">
        <div class="modal-content">
            <h2>Cu·ªôc g·ªçi ƒë·∫øn</h2>
            <p id="callerInfo">ƒêang c√≥ cu·ªôc g·ªçi t·ª´: <span id="callerName"></span></p>
            <div class="modal-buttons">
                <button onclick="acceptCall()" class="accept-call">Ch·∫•p nh·∫≠n</button>
                <button onclick="rejectCall()" class="reject-call">T·ª´ ch·ªëi</button>
            </div>
        </div>
    </div>

    <div id="callingStatus" class="calling-status">
        ƒêang g·ªçi...
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script>
        let socket;
        let localStream;
        let peerConnection;
        let currentCall = null;
        let currentUser = null;
        let incomingCallData = null;

        // G·ªçi checkAuth khi trang load
        document.addEventListener('DOMContentLoaded', checkAuth);

        const configuration = {
            iceServers: [
                {
                    urls: [
                        'stun:stun.l.google.com:19302',
                        'stun:stun1.l.google.com:19302'
                    ]
                }
            ]
        };

        async function login() {
            const username = document.getElementById('loginUsername').value;
            const password = document.getElementById('loginPassword').value;

            try {
                const response = await fetch('/api/login', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, password })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message);
                }

                const data = await response.json();
                currentUser = data.user;
                
                // L∆∞u th√¥ng tin v√†o localStorage
                localStorage.setItem('auth', JSON.stringify({
                    user: data.user,
                    token: data.token,
                    lastLogin: new Date().toISOString()
                }));
                
                // K·∫øt n·ªëi WebSocket v·ªõi token
                connectSocket(data.token);

                // ·∫®n form ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω
                document.querySelector('.auth-container').style.display = 'none';
                document.querySelector('.call-section').style.display = 'block';

                updateStatus(`ƒê√£ ƒëƒÉng nh·∫≠p: ${currentUser.username}`);
            } catch (error) {
                alert(error.message || 'L·ªói ƒëƒÉng nh·∫≠p');
            }
        }

        async function register() {
            const username = document.getElementById('regUsername').value;
            const email = document.getElementById('regEmail').value;
            const password = document.getElementById('regPassword').value;

            try {
                const response = await fetch('/api/register', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ username, email, password })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.message);
                }

                const data = await response.json();
                currentUser = data.user;
                
                // K·∫øt n·ªëi WebSocket v·ªõi token
                connectSocket(data.token);

                // ·∫®n form ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω
                document.querySelector('.auth-container').style.display = 'none';
                document.querySelector('.call-section').style.display = 'block';

                updateStatus(`ƒê√£ ƒëƒÉng k√Ω v√† ƒëƒÉng nh·∫≠p: ${currentUser.username}`);
            } catch (error) {
                alert(error.message || 'L·ªói ƒëƒÉng k√Ω');
            }
        }

        function logout() {
            if (socket) {
                socket.disconnect();
            }
            currentUser = null;
            // X√≥a th√¥ng tin ƒëƒÉng nh·∫≠p kh·ªèi localStorage
            localStorage.removeItem('auth');
            cleanup();

            // Hi·ªÉn th·ªã l·∫°i form ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω
            document.querySelector('.auth-container').style.display = 'flex';
            document.querySelector('.call-section').style.display = 'none';

            // Reset c√°c form
            document.getElementById('loginUsername').value = '';
            document.getElementById('loginPassword').value = '';
            document.getElementById('regUsername').value = '';
            document.getElementById('regEmail').value = '';
            document.getElementById('regPassword').value = '';
        }

        function connectSocket(token) {
            // K·∫øt n·ªëi t·ªõi WebSocket server v·ªõi token
            socket = io('http://localhost:62860', {
                query: {
                    token: token
                }
            });

            setupSocketListeners();
            setupLocalStream();
        }

        function setupSocketListeners() {
            socket.on('connect', () => {
                console.log('‚úÖ Socket connected successfully', {
                    socketId: socket.id,
                    userId: currentUser?._id,
                    username: currentUser?.username
                });
                updateStatus('ƒê√£ k·∫øt n·ªëi t·ªõi server');
            });

            socket.on('disconnect', () => {
                console.log('‚ùå Socket disconnected');
                updateStatus('M·∫•t k·∫øt n·ªëi t·ªõi server');
                cleanup();
            });

            socket.on('connect_error', (error) => {
                console.error('‚ùå Socket connection error:', error);
                updateStatus('L·ªói k·∫øt n·ªëi: ' + error.message);
            });

            socket.on('incoming_call', async (data) => {
                try {
                    console.log('üìû Incoming call received:', {
                        from: data.from,
                        fromUsername: data.fromUsername,
                        type: data.type,
                        timestamp: new Date().toISOString()
                    });
                    
                    if (!data || !data.from || !data.fromUsername) {
                        throw new Error('D·ªØ li·ªáu cu·ªôc g·ªçi kh√¥ng h·ª£p l·ªá');
                    }

                    // Ki·ªÉm tra xem c√≥ ƒëang trong cu·ªôc g·ªçi kh√°c kh√¥ng
                    if (currentCall) {
                        console.log('‚ùå Reject call - Already in another call', {
                            currentCall,
                            newCall: data.from
                        });
                        socket.emit('call_response', {
                            targetUserId: data.from,
                            accepted: false,
                            reason: 'busy'
                        });
                        return;
                    }

                    // Y√™u c·∫ßu quy·ªÅn th√¥ng b√°o n·∫øu ch∆∞a c√≥
                    if (Notification.permission !== 'granted') {
                        await Notification.requestPermission();
                    }

                    // Hi·ªÉn th·ªã th√¥ng b√°o desktop
                    if (Notification.permission === 'granted') {
                        const notification = new Notification('Cu·ªôc g·ªçi ƒë·∫øn', {
                            body: `${data.fromUsername} ƒëang g·ªçi cho b·∫°n`,
                            requireInteraction: true
                        });
                        
                        notification.onclick = function() {
                            window.focus();
                            this.close();
                        };
                    }

                    // L∆∞u th√¥ng tin cu·ªôc g·ªçi ƒë·∫øn
                    incomingCallData = data;
                    
                    // Hi·ªÉn th·ªã modal v√† ph√°t √¢m b√°o
                    showIncomingCall(data);
                    
                    // T·ª± ƒë·ªông t·ª´ ch·ªëi sau 30 gi√¢y n·∫øu kh√¥ng ph·∫£n h·ªìi
                    setTimeout(() => {
                        if (incomingCallData && incomingCallData.from === data.from) {
                            console.log('‚è∞ Auto rejecting call after timeout', {
                                from: data.from,
                                timestamp: new Date().toISOString()
                            });
                            rejectCall('timeout');
                        }
                    }, 30000);

                } catch (error) {
                    console.error('‚ùå Error handling incoming call:', error);
                    if (data && data.from) {
                        socket.emit('call_response', {
                            targetUserId: data.from,
                            accepted: false,
                            reason: 'error'
                        });
                    }
                }
            });

            socket.on('call_accepted', async (data) => {
                console.log('‚úÖ Call accepted:', {
                    from: data.from,
                    username: data.username,
                    timestamp: new Date().toISOString()
                });
                hideCallingStatus();
                updateStatus('Cu·ªôc g·ªçi ƒë∆∞·ª£c ch·∫•p nh·∫≠n');
                await setupPeerConnection(data.from, true);
            });

            socket.on('call_rejected', (data) => {
                console.log('‚ùå Call rejected:', {
                    from: data.from,
                    reason: data.reason,
                    timestamp: new Date().toISOString()
                });
                hideCallingStatus();
                let message = 'Cu·ªôc g·ªçi b·ªã t·ª´ ch·ªëi';
                
                // Th√™m l√Ω do t·ª´ ch·ªëi n·∫øu c√≥
                if (data.reason) {
                    switch(data.reason) {
                        case 'busy':
                            message += ': Ng∆∞·ªùi d√πng ƒëang b·∫≠n';
                            break;
                        case 'timeout':
                            message += ': Kh√¥ng c√≥ ph·∫£n h·ªìi';
                            break;
                        case 'error':
                            message += ': L·ªói k·∫øt n·ªëi';
                            break;
                        default:
                            message += ': ' + data.reason;
                    }
                }
                
                updateStatus(message);
                cleanup();
            });

            socket.on('call_error', (error) => {
                console.error('‚ùå Call error:', error);
                updateStatus('L·ªói cu·ªôc g·ªçi: ' + error.message);
            });

            socket.on('offer', async (data) => {
                try {
                    console.log('üì® Received offer:', {
                        from: data.from,
                        timestamp: new Date().toISOString()
                    });
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    
                    console.log('üì§ Sending answer to:', data.from);
                    socket.emit('answer', {
                        answer,
                        targetUserId: data.from
                    });
                } catch (error) {
                    console.error('‚ùå Error handling offer:', error);
                }
            });

            socket.on('answer', async (data) => {
                try {
                    console.log('üì® Received answer:', {
                        from: data.from,
                        timestamp: new Date().toISOString()
                    });
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                } catch (error) {
                    console.error('‚ùå Error handling answer:', error);
                }
            });

            socket.on('ice_candidate', async (data) => {
                try {
                    console.log('üßä Received ICE candidate:', {
                        from: data.from,
                        timestamp: new Date().toISOString()
                    });
                    if (data.candidate) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                    }
                } catch (error) {
                    console.error('‚ùå Error handling ICE candidate:', error);
                }
            });

            socket.on('call_ended', () => {
                console.log('üìû Call ended');
                hideCallingStatus();
                hideIncomingCall();
                updateStatus('Cu·ªôc g·ªçi k·∫øt th√∫c');
                cleanup();
            });
        }

        async function setupLocalStream() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                document.getElementById('localVideo').srcObject = localStream;
            } catch (error) {
                console.error('Error accessing media devices:', error);
                updateStatus('L·ªói truy c·∫≠p camera/mic');
            }
        }

        async function setupPeerConnection(targetUserId, isInitiator) {
            peerConnection = new RTCPeerConnection(configuration);

            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice_candidate', {
                        candidate: event.candidate,
                        targetUserId
                    });
                }
            };

            peerConnection.ontrack = (event) => {
                document.getElementById('remoteVideo').srcObject = event.streams[0];
            };

            if (isInitiator) {
                try {
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    socket.emit('offer', {
                        offer,
                        targetUserId
                    });
                } catch (error) {
                    console.error('Error creating offer:', error);
                }
            }

            currentCall = targetUserId;
        }

        async function startCall() {
            const targetUserId = document.getElementById('targetUserId').value;
            if (!targetUserId) {
                alert('Vui l√≤ng nh·∫≠p ID ng∆∞·ªùi nh·∫≠n');
                return;
            }

            console.log('üìû Initiating call:', {
                targetUserId,
                type: 'video',
                timestamp: new Date().toISOString()
            });

            showCallingStatus();
            updateStatus('ƒêang g·ªçi...');
            
            socket.emit('call_user', {
                targetUserId,
                type: 'video'
            });
        }

        function endCall() {
            if (currentCall) {
                socket.emit('end_call', {
                    targetUserId: currentCall
                });
                hideCallingStatus();
                cleanup();
            }
        }

        function cleanup() {
            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }
            document.getElementById('remoteVideo').srcObject = null;
            currentCall = null;
            hideCallingStatus();
            hideIncomingCall();
            updateStatus(currentUser ? `ƒê√£ ƒëƒÉng nh·∫≠p: ${currentUser.username}` : 'Ch∆∞a ƒëƒÉng nh·∫≠p');
        }

        function toggleAudio() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                audioTrack.enabled = !audioTrack.enabled;
                document.getElementById('audioBtn').textContent = 
                    audioTrack.enabled ? 'T·∫Øt mic' : 'B·∫≠t mic';
            }
        }

        function toggleVideo() {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                videoTrack.enabled = !videoTrack.enabled;
                document.getElementById('videoBtn').textContent = 
                    videoTrack.enabled ? 'T·∫Øt camera' : 'B·∫≠t camera';
            }
        }

        function updateStatus(message) {
            document.getElementById('connectionStatus').textContent = message;
        }

        function showIncomingCall(data) {
            console.log('Incoming call data:', data); // Debug log
            incomingCallData = data;
            const callerName = document.getElementById('callerName');
            callerName.textContent = data.fromUsername || data.from;
            const modal = document.getElementById('incomingCallModal');
            modal.style.display = 'block';
            // Ph√°t √¢m thanh th√¥ng b√°o
            playRingtone();
        }

        function hideIncomingCall() {
            const modal = document.getElementById('incomingCallModal');
            modal.style.display = 'none';
            incomingCallData = null;
            stopRingtone();
        }

        function showCallingStatus() {
            const status = document.getElementById('callingStatus');
            status.style.display = 'block';
        }

        function hideCallingStatus() {
            const status = document.getElementById('callingStatus');
            status.style.display = 'none';
        }

        async function acceptCall() {
            if (!incomingCallData) return;
            
            console.log('‚úÖ Accepting call from:', {
                from: incomingCallData.from,
                timestamp: new Date().toISOString()
            });
            
            hideIncomingCall();
            updateStatus('ƒêang k·∫øt n·ªëi cu·ªôc g·ªçi...');
            
            try {
                await setupLocalStream();
                
                socket.emit('call_response', {
                    targetUserId: incomingCallData.from,
                    accepted: true
                });
                
                await setupPeerConnection(incomingCallData.from, false);
            } catch (error) {
                console.error('‚ùå Error accepting call:', error);
                updateStatus('L·ªói khi k·∫øt n·ªëi cu·ªôc g·ªçi');
            }
        }

        function rejectCall(reason) {
            if (!incomingCallData) return;
            
            console.log('‚ùå Rejecting call:', {
                from: incomingCallData.from,
                reason,
                timestamp: new Date().toISOString()
            });
            
            socket.emit('call_response', {
                targetUserId: incomingCallData.from,
                accepted: false,
                reason: reason
            });
            
            hideIncomingCall();
            updateStatus(`ƒê√£ t·ª´ ch·ªëi cu·ªôc g·ªçi. L√Ω do: ${reason}`);
        }

        // Th√™m √¢m thanh th√¥ng b√°o
        let ringtone;
        function playRingtone() {
            ringtone = new Audio('https://assets.mixkit.co/active_storage/sfx/2912/2912-preview.mp3');
            ringtone.loop = true;
            ringtone.play().catch(e => console.log('Kh√¥ng th·ªÉ ph√°t nh·∫°c chu√¥ng:', e));
        }

        function stopRingtone() {
            if (ringtone) {
                ringtone.pause();
                ringtone.currentTime = 0;
            }
        }

        // Th√™m h√†m ki·ªÉm tra ƒëƒÉng nh·∫≠p khi load trang
        function checkAuth() {
            const auth = localStorage.getItem('auth');
            if (auth) {
                const { user, token } = JSON.parse(auth);
                currentUser = user;
                connectSocket(token);
                document.querySelector('.auth-container').style.display = 'none';
                document.querySelector('.call-section').style.display = 'block';
                updateStatus(`ƒê√£ ƒëƒÉng nh·∫≠p: ${currentUser.username}`);
            }
        }
    </script>
</body>
</html> 