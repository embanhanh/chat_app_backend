<!DOCTYPE html>
<html lang="vi">
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<head>
    <meta charset="UTF-8">
    <title>Test WebRTC Video Call</title>
    <style>
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            max-width: 1200px;
            margin: 0 auto;
        }
        .auth-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .auth-form {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
        }
        .form-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .call-section {
            width: 100%;
            display: flex;
            flex-direction: column;
            gap: 20px;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            background-color: #f8f9fa;
            width: 100%;
        }
        .controls-container {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(255, 255, 255, 0.9);
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
            z-index: 1000;
            width: auto;
            display: flex;
            gap: 10px;
            justify-content: center;
        }
        .video-section {
            margin-bottom: 80px; /* ƒê·ªÉ tr√°nh b·ªã che b·ªüi controls fixed */
            width: 100%;
        }
        .video-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            width: 100%;
        }
        .video-wrapper {
            position: relative;
            width: 100%;
            padding-top: 75%; /* T·ª∑ l·ªá 4:3 */
        }
        .video-wrapper video {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            object-fit: cover;
            border: 1px solid #ccc;
            border-radius: 8px;
        }
        .video-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 4px;
            font-size: 14px;
            z-index: 1;
        }
        .remote-videos-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            width: 100%;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            font-weight: bold;
            transition: background-color 0.3s;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }
        button.end-call {
            background-color: #dc3545;
        }
        button.end-call:hover {
            background-color: #c82333;
        }
        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            min-width: 200px;
            background-color: white;
        }
        .muted-indicator {
            position: absolute;
            top: 10px;
            right: 10px;
            background-color: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px;
            border-radius: 4px;
            z-index: 1;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            align-items: center;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        .modal-content {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            min-width: 300px;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        .accept-call {
            background-color: #28a745 !important;
        }
        .reject-call {
            background-color: #dc3545 !important;
        }
        .calling-status {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Test WebRTC Video Call</h1>
        
        <div class="auth-container">
            <!-- Form ƒëƒÉng nh·∫≠p -->
            <div class="auth-form" id="loginForm">
                <h2>ƒêƒÉng nh·∫≠p</h2>
                <div class="form-group">
                    <label for="loginUsername">Username</label>
                    <input type="text" id="loginUsername" required>
                </div>
                <div class="form-group">
                    <label for="loginPassword">Password</label>
                    <input type="password" id="loginPassword" required>
                </div>
                <button onclick="login()">ƒêƒÉng nh·∫≠p</button>
            </div>

            <!-- Form ƒëƒÉng k√Ω -->
            <div class="auth-form" id="registerForm">
                <h2>ƒêƒÉng k√Ω</h2>
                <div class="form-group">
                    <label for="regUsername">Username</label>
                    <input type="text" id="regUsername" required>
                </div>
                <div class="form-group">
                    <label for="regEmail">Email</label>
                    <input type="email" id="regEmail" required>
                </div>
                <div class="form-group">
                    <label for="regPassword">Password</label>
                    <input type="password" id="regPassword" required>
                </div>
                <button onclick="register()">ƒêƒÉng k√Ω</button>
            </div>
        </div>

        <div class="call-section" style="display: none;">
            <div class="status" id="connectionStatus">Ch∆∞a k·∫øt n·ªëi</div>
            
            <div class="video-container">
                <div class="local-video-container">
                    <h3>Local Video</h3>
                    <div class="video-wrapper">
                        <video id="localVideo" autoplay playsinline muted></video>
                        <div class="video-label">B·∫°n</div>
                        <div class="muted-indicator" id="localMutedIndicator" style="display: none;">
                            üîá ƒê√£ t·∫Øt ti·∫øng
                        </div>
                    </div>
                </div>
                <div class="remote-videos-container" id="remoteVideos">
                </div>
            </div>

            <div class="controls" id="callControls">
                <select id="conversationSelect">
                    <option value="">Ch·ªçn cu·ªôc tr√≤ chuy·ªán</option>
                </select>
                <button onclick="startCall()">G·ªçi</button>
                <button onclick="endCall()" class="end-call">K·∫øt th√∫c</button>
                <button onclick="toggleAudio()" id="audioBtn">T·∫Øt mic</button>
                <button onclick="toggleVideo()" id="videoBtn">T·∫Øt camera</button>
                <button onclick="logout()" class="end-call">ƒêƒÉng xu·∫•t</button>
            </div>

            <div class="controls" id="inCallControls" style="display: none;">
                <button onclick="endCall()" class="end-call">K·∫øt th√∫c</button>
                <button onclick="toggleAudio()" id="audioBtn">T·∫Øt mic</button>
                <button onclick="toggleVideo()" id="videoBtn">T·∫Øt camera</button>
            </div>
        </div>
    </div>

    <div id="incomingCallModal" class="modal">
        <div class="modal-content">
            <h2>Cu·ªôc g·ªçi ƒë·∫øn</h2>
            <p id="callerInfo">ƒêang c√≥ cu·ªôc g·ªçi t·ª´: <span id="callerName"></span></p>
            <div class="modal-buttons">
                <button onclick="acceptCall()" class="accept-call">Ch·∫•p nh·∫≠n</button>
                <button onclick="rejectCall()" class="reject-call">T·ª´ ch·ªëi</button>
            </div>
        </div>
    </div>

    <div id="callingStatus" class="calling-status">
        ƒêang g·ªçi...
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        let socket;
        let localStream;
        let peerConnections = new Map();
        let currentCall = null;
        let currentUser = null;
        let incomingCallData = null;
        let participantInfo = new Map();

        // G·ªçi checkAuth khi trang load
        document.addEventListener('DOMContentLoaded', checkAuth);

        const configuration = {
            iceServers: [
                {
                    urls: [
                        'stun:stun.l.google.com:19302',
                        'stun:stun1.l.google.com:19302'
                    ]
                }
            ]
        };

        async function login() {
            const username = document.getElementById('loginUsername').value;
            const password = document.getElementById('loginPassword').value;

            try {
                const response = await axios.post('/api/login', { username, password });
                const data = response.data;
                currentUser = data.user;
                
                // L∆∞u th√¥ng tin v√†o localStorage
                localStorage.setItem('auth', JSON.stringify({
                    user: data.user,
                    token: data.token,
                    lastLogin: new Date().toISOString()
                }));
                
                // K·∫øt n·ªëi WebSocket v·ªõi token
                connectSocket(data.token);

                // ·∫®n form ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω
                document.querySelector('.auth-container').style.display = 'none';
                document.querySelector('.call-section').style.display = 'block';

                updateStatus(`ƒê√£ ƒëƒÉng nh·∫≠p: ${currentUser.username}`);
            } catch (error) {
                alert(error.response?.data?.message || 'L·ªói ƒëƒÉng nh·∫≠p');
            }
        }

        async function register() {
            const username = document.getElementById('regUsername').value;
            const email = document.getElementById('regEmail').value;
            const password = document.getElementById('regPassword').value;

            try {
                const response = await axios.post('/api/register', { username, email, password });
                const data = response.data;
                currentUser = data.user;
                
                // K·∫øt n·ªëi WebSocket v·ªõi token
                connectSocket(data.token);

                // ·∫®n form ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω
                document.querySelector('.auth-container').style.display = 'none';
                document.querySelector('.call-section').style.display = 'block';

                updateStatus(`ƒê√£ ƒëƒÉng k√Ω v√† ƒëƒÉng nh·∫≠p: ${currentUser.username}`);
            } catch (error) {
                alert(error.response?.data?.message || 'L·ªói ƒëƒÉng k√Ω');
            }
        }

        function logout() {
            if (socket) {
                socket.disconnect();
            }
            currentUser = null;
            // X√≥a th√¥ng tin ƒëƒÉng nh·∫≠p kh·ªèi localStorage
            localStorage.removeItem('auth');
            cleanup();

            // Hi·ªÉn th·ªã l·∫°i form ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω
            document.querySelector('.auth-container').style.display = 'flex';
            document.querySelector('.call-section').style.display = 'none';

            // Reset c√°c form
            document.getElementById('loginUsername').value = '';
            document.getElementById('loginPassword').value = '';
            document.getElementById('regUsername').value = '';
            document.getElementById('regEmail').value = '';
            document.getElementById('regPassword').value = '';
        }

        function connectSocket(token) {
            // K·∫øt n·ªëi t·ªõi WebSocket server v·ªõi token
            socket = io('http://localhost:63021', {
                query: {
                    token: token
                }
            });

            setupSocketListeners();
            setupLocalStream();
            loadConversations();
        }

        function setupSocketListeners() {
            socket.on('connect', () => {
                console.log('‚úÖ Socket connected successfully', {
                    socketId: socket.id,
                    userId: currentUser?._id,
                    username: currentUser?.username
                });
                updateStatus('ƒê√£ k·∫øt n·ªëi t·ªõi server');
            });

            socket.on('disconnect', () => {
                console.log('‚ùå Socket disconnected');
                updateStatus('M·∫•t k·∫øt n·ªëi t·ªõi server');
                cleanup();
            });

            socket.on('connect_error', (error) => {
                console.error('‚ùå Socket connection error:', error);
                updateStatus('L·ªói k·∫øt n·ªëi: ' + error.message);
            });

            socket.on('incoming_call', async (data) => {
                try {
                    console.log('üìû Incoming call received:', {
                        from: data.from,
                        fromUsername: data.fromUsername,
                        type: data.type,
                        timestamp: new Date().toISOString()
                    });
                    
                    if (!data || !data.from || !data.fromUsername) {
                        throw new Error('D·ªØ li·ªáu cu·ªôc g·ªçi kh√¥ng h·ª£p l·ªá');
                    }

                    // Ki·ªÉm tra xem c√≥ ƒëang trong cu·ªôc g·ªçi kh√°c kh√¥ng
                    if (currentCall) {
                        console.log('‚ùå Reject call - Already in another call', {
                            currentCall,
                            newCall: data.from
                        });
                        socket.emit('call_response', {
                            targetUserId: data.from,
                            accepted: false,
                            reason: 'busy'
                        });
                        return;
                    }

                    // Y√™u c·∫ßu quy·ªÅn th√¥ng b√°o n·∫øu ch∆∞a c√≥
                    if (Notification.permission !== 'granted') {
                        await Notification.requestPermission();
                    }

                    // Hi·ªÉn th·ªã th√¥ng b√°o desktop
                    if (Notification.permission === 'granted') {
                        const notification = new Notification('Cu·ªôc g·ªçi ƒë·∫øn', {
                            body: `${data.fromUsername} ƒëang g·ªçi cho b·∫°n`,
                            requireInteraction: true
                        });
                        
                        notification.onclick = function() {
                            window.focus();
                            this.close();
                        };
                    }

                    // L∆∞u th√¥ng tin cu·ªôc g·ªçi ƒë·∫øn
                    incomingCallData = data;
                    
                    // Hi·ªÉn th·ªã modal v√† ph√°t √¢m b√°o
                    showIncomingCall(data);
                    
                    // T·ª± ƒë·ªông t·ª´ ch·ªëi sau 30 gi√¢y n·∫øu kh√¥ng ph·∫£n h·ªìi
                    setTimeout(() => {
                        if (incomingCallData && incomingCallData.from === data.from) {
                            console.log('‚è∞ Auto rejecting call after timeout', {
                                from: data.from,
                                timestamp: new Date().toISOString()
                            });
                            rejectCall('timeout');
                        }
                    }, 30000);

                } catch (error) {
                    console.error('‚ùå Error handling incoming call:', error);
                    if (data && data.from) {
                        socket.emit('call_response', {
                            targetUserId: data.from,
                            accepted: false,
                            reason: 'error'
                        });
                    }
                }
            });

            socket.on('call_accepted', async (data) => {
                try {
                    console.log('‚úÖ Call accepted:', {
                        from: data.from,
                        username: data.username,
                        timestamp: new Date().toISOString()
                    });
                    hideCallingStatus();
                    updateStatus('Cu·ªôc g·ªçi ƒë∆∞·ª£c ch·∫•p nh·∫≠n');

                    // L∆∞u th√¥ng tin ng∆∞·ªùi d√πng
                    participantInfo.set(data.from, {
                        username: data.username || `User ${data.from}`
                    });

                    // Kh·ªüi t·∫°o currentCall n·∫øu ch∆∞a c√≥
                    if (!currentCall) {
                        currentCall = {
                            type: 'outgoing',
                            participants: new Set([data.from])
                        };
                    } else {
                        currentCall.participants.add(data.from);
                    }

                    // Kh·ªüi t·∫°o peer connection cho ng∆∞·ªùi ch·∫•p nh·∫≠n cu·ªôc g·ªçi
                    await setupPeerConnection(data.from, true);

                    // Th√¥ng b√°o cho ng∆∞·ªùi m·ªõi v·ªÅ nh·ªØng ng∆∞·ªùi ƒëang trong cu·ªôc g·ªçi
                    if (currentCall.participants.size > 1) {
                        const otherParticipants = Array.from(currentCall.participants)
                            .filter(id => id !== data.from);
                        
                        console.log('üì¢ Notifying new participant about existing participants:', otherParticipants);
                        socket.emit('notify_existing_participants', {
                            targetUserId: data.from,
                            participants: otherParticipants
                        });
                    }

                } catch (error) {
                    console.error('‚ùå Error in call_accepted:', error);
                    updateStatus('L·ªói khi thi·∫øt l·∫≠p cu·ªôc g·ªçi');
                }
            });

            socket.on('call_rejected', (data) => {
                console.log('‚ùå Call rejected:', {
                    from: data.from,
                    reason: data.reason,
                    timestamp: new Date().toISOString()
                });
                hideCallingStatus();
                let message = 'Cu·ªôc g·ªçi b·ªã t·ª´ ch·ªëi';
                
                // Th√™m l√Ω do t·ª´ ch·ªëi n·∫øu c√≥
                if (data.reason) {
                    switch(data.reason) {
                        case 'busy':
                            message += ': Ng∆∞·ªùi d√πng ƒëang b·∫≠n';
                            break;
                        case 'timeout':
                            message += ': Kh√¥ng c√≥ ph·∫£n h·ªìi';
                            break;
                        case 'error':
                            message += ': L·ªói k·∫øt n·ªëi';
                            break;
                        default:
                            message += ': ' + data.reason;
                    }
                }
                
                updateStatus(message);
                cleanup();
            });

            socket.on('call_error', (error) => {
                console.error('‚ùå Call error:', error);
                updateStatus('L·ªói cu·ªôc g·ªçi: ' + error.message);
            });

            async function waitForRemoteDescription(peerConnection) {
                return new Promise((resolve) => {
                    if (peerConnection.remoteDescription) {
                        resolve();
                        return;
                    }
                    const checkInterval = setInterval(() => {
                        if (peerConnection.remoteDescription) {
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 100);
                });
            }

            socket.on('ice_candidate', async (data) => {
                try {
                    const peerConnection = peerConnections.get(data.from);
                    if (!peerConnection) {
                        console.error('‚ùå No peer connection found for user:', data.from);
                        return;
                    }

                    // N·∫øu ch∆∞a c√≥ remote description, cache candidate
                    if (!peerConnection.remoteDescription) {
                        console.log('‚è≥ Caching ICE candidate - No remote description yet');
                        if (!peerConnection.cachedCandidates) {
                            peerConnection.cachedCandidates = [];
                        }
                        peerConnection.cachedCandidates.push(data.candidate);
                        return;
                    }

                    // Th√™m candidate n·∫øu tr·∫°ng th√°i cho ph√©p
                    if (data.candidate && ['stable', 'have-remote-offer', 'have-local-offer'].includes(peerConnection.signalingState)) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                        console.log('‚úÖ ICE candidate added successfully');
                    }
                } catch (error) {
                    console.error('‚ùå Error handling ICE candidate:', error);
                }
            });

            socket.on('offer', async (data) => {
                try {
                    console.log('üì® Received offer from:', data.from);
                    
                    // T·∫°o peer connection cho ng∆∞·ªùi g·ª≠i offer n·∫øu ch∆∞a c√≥
                    let peerConnection = peerConnections.get(data.from);
                    if (!peerConnection) {
                        peerConnection = await setupPeerConnection(data.from, false);
                    }

                    // Thi·∫øt l·∫≠p remote description t·ª´ offer nh·∫≠n ƒë∆∞·ª£c
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));

                    // T·∫°o v√† g·ª≠i answer
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    
                    console.log('üì§ Sending answer to:', data.from);
                    socket.emit('answer', {
                        answer,
                        targetUserId: data.from
                    });

                    // L∆∞u th√¥ng tin cu·ªôc g·ªçi
                    if (!currentCall) {
                        currentCall = {
                            type: 'incoming',
                            participants: new Set([data.from])
                        };
                    } else {
                        currentCall.participants.add(data.from);
                    }
                } catch (error) {
                    console.error('‚ùå Error handling offer:', error);
                    socket.emit('call_error', {
                        targetUserId: data.from,
                        message: 'L·ªói x·ª≠ l√Ω offer: ' + error.message
                    });
                }
            });

            socket.on('answer', async (data) => {
                try {
                    console.log('üì® Received answer from:', data.from);
                    const peerConnection = peerConnections.get(data.from);
                    
                    if (!peerConnection) {
                        throw new Error('No peer connection found for user: ' + data.from);
                    }

                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                    console.log('‚úÖ Remote description set successfully');

                    // Th√™m ng∆∞·ªùi tham gia v√†o danh s√°ch
                    if (!currentCall) {
                        currentCall = {
                            type: 'outgoing',
                            participants: new Set([data.from])
                        };
                    } else {
                        currentCall.participants.add(data.from);
                    }

                } catch (error) {
                    console.error('‚ùå Error handling answer:', error);
                }
            });

            socket.on('call_ended', () => {
                console.log('üìû Call ended');
                hideCallingStatus();
                hideIncomingCall();
                updateStatus('Cu·ªôc g·ªçi k·∫øt th√∫c');
                cleanup();
            });

            // X·ª≠ l√Ω th√¥ng b√°o v·ªÅ ng∆∞·ªùi tham gia hi·ªán c√≥
            socket.on('existing_participants', async (data) => {
                try {
                    console.log('üì¢ Received existing participants:', data.participants);
                    
                    // T·∫°o k·∫øt n·ªëi v·ªõi m·ªói ng∆∞·ªùi tham gia hi·ªán c√≥
                    for (const participantId of data.participants) {
                        if (participantId !== socket.userId && !peerConnections.has(participantId)) {
                            console.log('üîÑ Creating connection with existing participant:', participantId);
                            await setupPeerConnection(participantId, true);
                        }
                    }
                } catch (error) {
                    console.error('‚ùå Error connecting to existing participants:', error);
                }
            });

            // X·ª≠ l√Ω khi c√≥ ng∆∞·ªùi m·ªõi tham gia
            socket.on('new_participant', async (data) => {
                try {
                    console.log('üë§ New participant joined:', data);
                    
                    // L∆∞u th√¥ng tin ng∆∞·ªùi d√πng m·ªõi
                    participantInfo.set(data.userId, {
                        username: data.username || `User ${data.userId}`
                    });

                    if (data.userId !== socket.userId && !peerConnections.has(data.userId)) {
                        // Ch·ªâ ng∆∞·ªùi ƒë√£ trong cu·ªôc g·ªçi m·ªõi t·∫°o k·∫øt n·ªëi v·ªõi ng∆∞·ªùi m·ªõi
                        if (currentCall && currentCall.participants.size > 0) {
                            console.log('üîÑ Creating connection with new participant:', data.userId);
                            await setupPeerConnection(data.userId, false);
                        }
                    }

                    // Th√™m v√†o danh s√°ch ng∆∞·ªùi tham gia
                    if (currentCall) {
                        currentCall.participants.add(data.userId);
                    }
                } catch (error) {
                    console.error('‚ùå Error handling new participant:', error);
                }
            });

            // C·∫≠p nh·∫≠t h√†m x·ª≠ l√Ω khi ng∆∞·ªùi d√πng r·ªùi cu·ªôc g·ªçi
            socket.on('participant_left', (data) => {
                try {
                    console.log('üëã Participant left:', data.userId);
                    
                    // X√≥a th√¥ng tin ng∆∞·ªùi d√πng
                    participantInfo.delete(data.userId);
                    
                    // ƒê√≥ng k·∫øt n·ªëi v√† x√≥a video
                    const peerConnection = peerConnections.get(data.userId);
                    if (peerConnection) {
                        peerConnection.close();
                        peerConnections.delete(data.userId);
                    }
                    removeRemoteVideo(data.userId);

                    // C·∫≠p nh·∫≠t danh s√°ch ng∆∞·ªùi tham gia
                    if (currentCall) {
                        currentCall.participants.delete(data.userId);
                        if (currentCall.participants.size === 0) {
                            cleanup();
                        }
                    }

                    console.log('‚úÖ Successfully handled participant leaving');
                } catch (error) {
                    console.error('‚ùå Error handling participant leaving:', error);
                }
            });

            // Th√™m x·ª≠ l√Ω s·ª± ki·ªán khi ng∆∞·ªùi kh√°c thay ƒë·ªïi tr·∫°ng th√°i audio
            socket.on('audio_state_changed', (data) => {
                const mutedIndicator = document.getElementById(`muted-indicator-${data.userId}`);
                if (mutedIndicator) {
                    mutedIndicator.style.display = data.isMuted ? 'block' : 'none';
                }
            });
        }

        async function setupLocalStream() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                document.getElementById('localVideo').srcObject = localStream;
            } catch (error) {
                console.error('Error accessing media devices:', error);
                updateStatus('L·ªói truy c·∫≠p camera/mic');
            }
        }

        async function setupPeerConnection(targetUserId, isInitiator) {
            console.log('setupPeerConnection targetUserId:', targetUserId, 'isInitiator:', isInitiator);
            
            // Ki·ªÉm tra n·∫øu ƒë√£ c√≥ k·∫øt n·ªëi
            if (peerConnections.has(targetUserId)) {
                console.log('‚ö†Ô∏è Peer connection already exists for:', targetUserId);
                return peerConnections.get(targetUserId);
            }

            const peerConnection = new RTCPeerConnection(configuration);
            peerConnections.set(targetUserId, peerConnection);
            
            // Th√™m local stream
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // X·ª≠ l√Ω ICE candidate
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('üì§ Sending ICE candidate to:', targetUserId);
                    socket.emit('ice_candidate', {
                        candidate: event.candidate,
                        targetUserId: targetUserId
                    });
                }
            };

            // X·ª≠ l√Ω remote stream
            peerConnection.ontrack = (event) => {
                console.log('üì• Received remote track from:', targetUserId);
                updateRemoteVideo(targetUserId, event.streams[0]);
            };

            // X·ª≠ l√Ω thay ƒë·ªïi tr·∫°ng th√°i k·∫øt n·ªëi
            peerConnection.onconnectionstatechange = () => {
                console.log(`Connection state with ${targetUserId}:`, peerConnection.connectionState);
                if (peerConnection.connectionState === 'connected') {
                    // Th√™m v√†o danh s√°ch ng∆∞·ªùi tham gia n·∫øu ch∆∞a c√≥
                    if (currentCall) {
                        currentCall.participants.add(targetUserId);
                    } else {
                        currentCall = {
                            type: isInitiator ? 'outgoing' : 'incoming',
                            participants: new Set([targetUserId])
                        };
                    }
                }
            };

            // Ch·ªâ ng∆∞·ªùi g·ªçi (caller) t·∫°o v√† g·ª≠i offer
            if (isInitiator) {
                try {
                    console.log('üì§ Creating and sending offer to:', targetUserId);
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    
                    socket.emit('offer', {
                        targetUserId: targetUserId,
                        offer: offer
                    });
                } catch (error) {
                    console.error('‚ùå Error creating offer:', error);
                    updateStatus('L·ªói khi t·∫°o offer');
                }
            }

            return peerConnection;
        }

        async function startCall() {
            try {
                const conversationId = document.getElementById('conversationSelect').value;
                if (!conversationId) {
                    alert('Vui l√≤ng ch·ªçn cu·ªôc tr√≤ chuy·ªán');
                    return;
                }

                // G·ª≠i y√™u c·∫ßu g·ªçi ƒë·∫øn server
                socket.emit('call_user', {
                    conversationId,
                    type: 'video'
                });

                // Hi·ªÉn th·ªã UI cu·ªôc g·ªçi
                document.getElementById('callControls').style.display = 'none';
                document.getElementById('inCallControls').style.display = 'block';
                showCallingStatus();
            } catch (error) {
                console.error('L·ªói khi b·∫Øt ƒë·∫ßu cu·ªôc g·ªçi:', error);
                alert('Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu cu·ªôc g·ªçi: ' + error.message);
            }
        }

        function endCall() {
            try {
                console.log('üìû Ending call');
                
                // G·ª≠i t√≠n hi·ªáu k·∫øt th√∫c cu·ªôc g·ªçi ƒë·∫øn t·∫•t c·∫£ ng∆∞·ªùi tham gia
                if (currentCall?.participants) {
                    currentCall.participants.forEach(participantId => {
                        socket.emit('end_call', {
                            targetUserId: participantId
                        });
                    });
                }

                // D·ªçn d·∫πp
                cleanup();
                
                console.log('‚úÖ Call ended successfully');
            } catch (error) {
                console.error('‚ùå Error ending call:', error);
            }
        }

        function cleanup() {
            try {
                console.log('üßπ Cleaning up call resources');
                
                // D·ªçn d·∫πp c√°c k·∫øt n·ªëi peer
                peerConnections.forEach((peerConnection, userId) => {
                    console.log(`Closing peer connection for user: ${userId}`);
                    // ƒê√≥ng t·∫•t c·∫£ tracks
                    peerConnection.getSenders().forEach(sender => {
                        if (sender.track) {
                            sender.track.stop();
                        }
                    });
                    peerConnection.getReceivers().forEach(receiver => {
                        if (receiver.track) {
                            receiver.track.stop();
                        }
                    });
                    peerConnection.close();
                    peerConnections.delete(userId);
                    
                    // X√≥a video c·ªßa ng∆∞·ªùi d√πng n√†y
                    removeRemoteVideo(userId);
                });

                // Reset c√°c bi·∫øn
                currentCall = null;
                incomingCallData = null;

                // Reset UI
                document.getElementById('callControls').style.display = 'block';
                document.getElementById('inCallControls').style.display = 'none';
                hideCallingStatus();
                hideIncomingCall();
                stopRingtone();

                console.log('‚úÖ Cleanup completed');
            } catch (error) {
                console.error('‚ùå Error during cleanup:', error);
            }
        }

        // Th√™m h√†m x√≥a video
        function removeRemoteVideo(userId) {
            try {
                console.log(`üóëÔ∏è Removing remote video for user: ${userId}`);
                const wrapper = document.getElementById(`video-wrapper-${userId}`);
                if (wrapper) {
                    const videoElement = wrapper.querySelector('video');
                    if (videoElement && videoElement.srcObject) {
                        videoElement.srcObject.getTracks().forEach(track => track.stop());
                        videoElement.srcObject = null;
                    }
                    wrapper.remove();
                    console.log(`‚úÖ Removed video wrapper for user: ${userId}`);
                }
            } catch (error) {
                console.error(`‚ùå Error removing video for user ${userId}:`, error);
            }
        }

        // Th√™m h√†m ƒë·ªÉ qu·∫£n l√Ω video elements
        function updateRemoteVideo(userId, stream) {
            try {
                console.log(`Updating remote video for user: ${userId}`);
                
                // X√≥a video c≈© n·∫øu c√≥
                const existingWrapper = document.getElementById(`video-wrapper-${userId}`);
                if (existingWrapper) {
                    existingWrapper.remove();
                }

                // T·∫°o wrapper m·ªõi
                const wrapper = document.createElement('div');
                wrapper.className = 'video-wrapper';
                wrapper.id = `video-wrapper-${userId}`;

                // T·∫°o video element
                const remoteVideo = document.createElement('video');
                remoteVideo.srcObject = stream;
                remoteVideo.autoplay = true;
                remoteVideo.playsInline = true;
                remoteVideo.className = 'remote-video';
                remoteVideo.id = `remote-video-${userId}`;

                // T·∫°o label hi·ªÉn th·ªã t√™n
                const label = document.createElement('div');
                label.className = 'video-label';
                // L·∫•y t√™n t·ª´ participantInfo
                const userInfo = participantInfo.get(userId);
                label.textContent = userInfo?.username || `User ${userId}`;

                // T·∫°o indicator cho tr·∫°ng th√°i t·∫Øt ti·∫øng
                const mutedIndicator = document.createElement('div');
                mutedIndicator.className = 'muted-indicator';
                mutedIndicator.id = `muted-indicator-${userId}`;
                mutedIndicator.style.display = 'none';
                mutedIndicator.textContent = 'üîá ƒê√£ t·∫Øt ti·∫øng';

                // Th√™m c√°c elements v√†o wrapper
                wrapper.appendChild(remoteVideo);
                wrapper.appendChild(label);
                wrapper.appendChild(mutedIndicator);

                // Th√™m wrapper v√†o container
                document.getElementById('remoteVideos').appendChild(wrapper);

                console.log('‚úÖ Remote video updated successfully');
            } catch (error) {
                console.error('‚ùå Error updating remote video:', error);
            }
        }

        function toggleAudio() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                audioTrack.enabled = !audioTrack.enabled;
                document.getElementById('audioBtn').textContent = 
                    audioTrack.enabled ? 'T·∫Øt mic' : 'B·∫≠t mic';
                
                // Hi·ªÉn th·ªã indicator
                document.getElementById('localMutedIndicator').style.display = 
                    audioTrack.enabled ? 'none' : 'block';

                // Th√¥ng b√°o cho ng∆∞·ªùi kh√°c v·ªÅ tr·∫°ng th√°i mic
                if (currentCall?.participants) {
                    socket.emit('audio_state_changed', {
                        isMuted: !audioTrack.enabled
                    });
                }
            }
        }

        function toggleVideo() {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                videoTrack.enabled = !videoTrack.enabled;
                document.getElementById('videoBtn').textContent = 
                    videoTrack.enabled ? 'T·∫Øt camera' : 'B·∫≠t camera';
            }
        }

        function updateStatus(message) {
            document.getElementById('connectionStatus').textContent = message;
        }

        function showIncomingCall(data) {
            try {
                console.log('üì± Showing incoming call UI:', data);
                incomingCallData = data; // L∆∞u data ngay khi hi·ªÉn th·ªã
                const callerName = document.getElementById('callerName');
                callerName.textContent = data.fromUsername || data.from;
                const modal = document.getElementById('incomingCallModal');
                modal.style.display = 'block';
                playRingtone();
            } catch (error) {
                console.error('‚ùå Error showing incoming call:', error);
            }
        }

        function hideIncomingCall() {
            try {
                const modal = document.getElementById('incomingCallModal');
                modal.style.display = 'none';
                stopRingtone();
                // KH√îNG x√≥a incomingCallData ·ªü ƒë√¢y v√¨ c√≤n c·∫ßn d√πng cho vi·ªác thi·∫øt l·∫≠p k·∫øt n·ªëi
            } catch (error) {
                console.error('‚ùå Error hiding incoming call:', error);
            }
        }

        function showCallingStatus() {
            const status = document.getElementById('callingStatus');
            status.style.display = 'block';
        }

        function hideCallingStatus() {
            const status = document.getElementById('callingStatus');
            status.style.display = 'none';
        }

        async function acceptCall() {
            try {
                console.log('Accepting call with data:', incomingCallData);
                
                if (!incomingCallData) {
                    console.error('‚ùå No incoming call data available');
                    updateStatus('L·ªói: Kh√¥ng c√≥ th√¥ng tin cu·ªôc g·ªçi');
                    return;
                }
                
                hideIncomingCall();
                updateStatus('ƒêang k·∫øt n·ªëi cu·ªôc g·ªçi...');

                // L∆∞u th√¥ng tin ng∆∞·ªùi g·ªçi
                participantInfo.set(incomingCallData.from, {
                    username: incomingCallData.fromUsername || `User ${incomingCallData.from}`
                });
                
                // G·ª≠i ph·∫£n h·ªìi ch·∫•p nh·∫≠n cu·ªôc g·ªçi
                socket.emit('call_response', {
                    targetUserId: incomingCallData.from,
                    accepted: true
                });

                // Kh·ªüi t·∫°o currentCall
                currentCall = {
                    type: 'incoming',
                    participants: new Set([incomingCallData.from])
                };
                
            } catch (error) {
                console.error('‚ùå Error in acceptCall:', error);
                updateStatus('L·ªói khi ch·∫•p nh·∫≠n cu·ªôc g·ªçi');
            }
        }

        function rejectCall(reason = 'rejected') {
            try {
                console.log('Rejecting call:', {
                    incomingCallData,
                    reason,
                    timestamp: new Date().toISOString()
                });
                
                if (!incomingCallData) {
                    console.error('‚ùå No incoming call data available');
                    return;
                }
                
                socket.emit('call_response', {
                    targetUserId: incomingCallData.from,
                    accepted: false,
                    reason: reason
                });
                
                hideIncomingCall();
                updateStatus('ƒê√£ t·ª´ ch·ªëi cu·ªôc g·ªçi');
                cleanup();
            } catch (error) {
                console.error('‚ùå Error in rejectCall:', error);
            }
        }

        // Th√™m √¢m thanh th√¥ng b√°o
        let ringtone;
        function playRingtone() {
            ringtone = new Audio('https://assets.mixkit.co/active_storage/sfx/2912/2912-preview.mp3');
            ringtone.loop = true;
            ringtone.play().catch(e => console.log('Kh√¥ng th·ªÉ ph√°t nh·∫°c chu√¥ng:', e));
        }

        function stopRingtone() {
            if (ringtone) {
                ringtone.pause();
                ringtone.currentTime = 0;
            }
        }

        // Th√™m h√†m ki·ªÉm tra ƒëƒÉng nh·∫≠p khi load trang
        function checkAuth() {
            const auth = localStorage.getItem('auth');
            if (auth) {
                const { user, token } = JSON.parse(auth);
                currentUser = user;
                connectSocket(token);
                document.querySelector('.auth-container').style.display = 'none';
                document.querySelector('.call-section').style.display = 'block';
                updateStatus(`ƒê√£ ƒëƒÉng nh·∫≠p: ${currentUser.username}`);
            }
        }

        // Th√™m h√†m load conversations
        async function loadConversations() {
            try {
                const auth = localStorage.getItem('auth');
                if (!auth) {
                    throw new Error('Ch∆∞a ƒëƒÉng nh·∫≠p');
                }

                const { token } = JSON.parse(auth);
                const response = await axios.get('http://localhost:63021/api/conversations', {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                const data = response.data;
                console.log('Danh s√°ch conversations:', data.conversations);
                
                const select = document.getElementById('conversationSelect');
                if (!select) {
                    console.error('Kh√¥ng t√¨m th·∫•y element conversationSelect');
                    return;
                }
                
                // X√≥a c√°c option c≈©
                select.innerHTML = '<option value="">Ch·ªçn cu·ªôc tr√≤ chuy·ªán</option>';
                
                // Th√™m c√°c option m·ªõi
                if (data.conversations && Array.isArray(data.conversations)) {
                    data.conversations.forEach(conv => {
                        if (!conv || !conv.conversationId) return; // S·ª≠a t·ª´ _id th√†nh conversationId
                        
                        const option = document.createElement('option');
                        option.value = conv.conversationId; // S·ª≠a t·ª´ _id th√†nh conversationId
                        
                        // Ki·ªÉm tra v√† x·ª≠ l√Ω t√™n hi·ªÉn th·ªã
                        let displayName = '';
                        if (conv.type === 'private') {
                            // V·ªõi private chat, hi·ªÉn th·ªã t√™n ng∆∞·ªùi d√πng kh√°c
                            displayName = conv.conversationId || 'Chat ri√™ng';
                        } else {
                            // V·ªõi group chat, hi·ªÉn th·ªã t√™n nh√≥m v√† s·ªë th√†nh vi√™n
                            displayName = conv.name ? 
                                `Nh√≥m: ${conv.name} (${conv.participants?.length || 0} th√†nh vi√™n)` : 
                                `Nh√≥m chat (${conv.participants?.length || 0} th√†nh vi√™n)`;
                        }
                        
                        option.textContent = displayName;
                        select.appendChild(option);
                    });

                    // Log s·ªë l∆∞·ª£ng options ƒë√£ th√™m
                    console.log(`ƒê√£ th√™m ${select.options.length - 1} cu·ªôc tr√≤ chuy·ªán v√†o combobox`);
                } else {
                    console.warn('Kh√¥ng c√≥ d·ªØ li·ªáu conversations ho·∫∑c ƒë·ªãnh d·∫°ng kh√¥ng ƒë√∫ng');
                }

                // Ki·ªÉm tra v√† log tr·∫°ng th√°i c·ªßa select
                console.log('Tr·∫°ng th√°i combobox:', {
                    visible: select.offsetParent !== null,
                    width: select.offsetWidth,
                    height: select.offsetHeight,
                    options: select.options.length
                });
            } catch (error) {
                console.error('L·ªói t·∫£i conversations:', error);
                alert(error.response?.data?.message || error.message);
            }
        }
    </script>
</body>
</html> 