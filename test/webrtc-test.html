<!DOCTYPE html>
<html lang="vi">
<script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
<head>
    <meta charset="UTF-8">
    <title>Test WebRTC Video Call</title>
    <style>
        .container {
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }
        .auth-container {
            display: flex;
            gap: 20px;
            margin-bottom: 20px;
        }
        .auth-form {
            border: 1px solid #ccc;
            padding: 20px;
            border-radius: 8px;
            width: 300px;
        }
        .form-group {
            margin-bottom: 15px;
        }
        .form-group label {
            display: block;
            margin-bottom: 5px;
        }
        .form-group input {
            width: 100%;
            padding: 8px;
            border: 1px solid #ccc;
            border-radius: 4px;
        }
        .video-container {
            display: flex;
            gap: 20px;
            margin: 20px 0;
        }
        video {
            width: 400px;
            height: 300px;
            border: 1px solid #ccc;
            border-radius: 8px;
        }
        .controls {
            display: flex;
            gap: 10px;
            margin: 10px 0;
            align-items: center;
        }
        select {
            padding: 8px;
            border-radius: 4px;
            border: 1px solid #ccc;
            min-width: 200px;
            background-color: white;
        }
        button {
            padding: 10px 20px;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
        }
        button:disabled {
            background-color: #ccc;
        }
        button.end-call {
            background-color: #dc3545;
        }
        .status {
            margin: 10px 0;
            padding: 10px;
            border-radius: 5px;
            background-color: #f8f9fa;
        }
        #targetUserId {
            padding: 8px;
            margin-right: 10px;
            border-radius: 4px;
            border: 1px solid #ccc;
        }
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            z-index: 1000;
        }
        .modal-content {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: white;
            padding: 20px;
            border-radius: 8px;
            text-align: center;
            min-width: 300px;
        }
        .modal-buttons {
            display: flex;
            justify-content: center;
            gap: 10px;
            margin-top: 20px;
        }
        .accept-call {
            background-color: #28a745 !important;
        }
        .reject-call {
            background-color: #dc3545 !important;
        }
        .calling-status {
            display: none;
            position: fixed;
            top: 20px;
            right: 20px;
            background-color: #007bff;
            color: white;
            padding: 10px 20px;
            border-radius: 5px;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Test WebRTC Video Call</h1>
        
        <div class="auth-container">
            <!-- Form ƒëƒÉng nh·∫≠p -->
            <div class="auth-form" id="loginForm">
                <h2>ƒêƒÉng nh·∫≠p</h2>
                <div class="form-group">
                    <label for="loginUsername">Username</label>
                    <input type="text" id="loginUsername" required>
                </div>
                <div class="form-group">
                    <label for="loginPassword">Password</label>
                    <input type="password" id="loginPassword" required>
                </div>
                <button onclick="login()">ƒêƒÉng nh·∫≠p</button>
            </div>

            <!-- Form ƒëƒÉng k√Ω -->
            <div class="auth-form" id="registerForm">
                <h2>ƒêƒÉng k√Ω</h2>
                <div class="form-group">
                    <label for="regUsername">Username</label>
                    <input type="text" id="regUsername" required>
                </div>
                <div class="form-group">
                    <label for="regEmail">Email</label>
                    <input type="email" id="regEmail" required>
                </div>
                <div class="form-group">
                    <label for="regPassword">Password</label>
                    <input type="password" id="regPassword" required>
                </div>
                <button onclick="register()">ƒêƒÉng k√Ω</button>
            </div>
        </div>

        <div class="call-section" style="display: none;">
            <div class="status" id="connectionStatus">Ch∆∞a k·∫øt n·ªëi</div>
            
            <div class="video-container">
                <div>
                    <h3>Local Video</h3>
                    <video id="localVideo" autoplay playsinline muted></video>
                </div>
                <div>
                    <h3>Remote Videos</h3>
                    <div id="remoteVideos"></div>
                </div>
            </div>

            <div class="controls" id="callControls">
                <select id="conversationSelect">
                    <option value="">Ch·ªçn cu·ªôc tr√≤ chuy·ªán</option>
                </select>
                <button onclick="startCall()">G·ªçi</button>
                <button onclick="endCall()" class="end-call">K·∫øt th√∫c</button>
                <button onclick="toggleAudio()" id="audioBtn">T·∫Øt mic</button>
                <button onclick="toggleVideo()" id="videoBtn">T·∫Øt camera</button>
                <button onclick="logout()" class="end-call">ƒêƒÉng xu·∫•t</button>
            </div>

            <div class="controls" id="inCallControls" style="display: none;">
                <button onclick="endCall()" class="end-call">K·∫øt th√∫c</button>
                <button onclick="toggleAudio()" id="audioBtn">T·∫Øt mic</button>
                <button onclick="toggleVideo()" id="videoBtn">T·∫Øt camera</button>
            </div>
        </div>
    </div>

    <div id="incomingCallModal" class="modal">
        <div class="modal-content">
            <h2>Cu·ªôc g·ªçi ƒë·∫øn</h2>
            <p id="callerInfo">ƒêang c√≥ cu·ªôc g·ªçi t·ª´: <span id="callerName"></span></p>
            <div class="modal-buttons">
                <button onclick="acceptCall()" class="accept-call">Ch·∫•p nh·∫≠n</button>
                <button onclick="rejectCall()" class="reject-call">T·ª´ ch·ªëi</button>
            </div>
        </div>
    </div>

    <div id="callingStatus" class="calling-status">
        ƒêang g·ªçi...
    </div>

    <script src="https://cdn.socket.io/4.7.2/socket.io.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/axios/dist/axios.min.js"></script>
    <script>
        let socket;
        let localStream;
        let peerConnections = new Map();
        let currentCall = null;
        let currentUser = null;
        let incomingCallData = null;

        // G·ªçi checkAuth khi trang load
        document.addEventListener('DOMContentLoaded', checkAuth);

        const configuration = {
            iceServers: [
                {
                    urls: [
                        'stun:stun.l.google.com:19302',
                        'stun:stun1.l.google.com:19302'
                    ]
                }
            ]
        };

        async function login() {
            const username = document.getElementById('loginUsername').value;
            const password = document.getElementById('loginPassword').value;

            try {
                const response = await axios.post('/api/login', { username, password });
                const data = response.data;
                currentUser = data.user;
                
                // L∆∞u th√¥ng tin v√†o localStorage
                localStorage.setItem('auth', JSON.stringify({
                    user: data.user,
                    token: data.token,
                    lastLogin: new Date().toISOString()
                }));
                
                // K·∫øt n·ªëi WebSocket v·ªõi token
                connectSocket(data.token);

                // ·∫®n form ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω
                document.querySelector('.auth-container').style.display = 'none';
                document.querySelector('.call-section').style.display = 'block';

                updateStatus(`ƒê√£ ƒëƒÉng nh·∫≠p: ${currentUser.username}`);
            } catch (error) {
                alert(error.response?.data?.message || 'L·ªói ƒëƒÉng nh·∫≠p');
            }
        }

        async function register() {
            const username = document.getElementById('regUsername').value;
            const email = document.getElementById('regEmail').value;
            const password = document.getElementById('regPassword').value;

            try {
                const response = await axios.post('/api/register', { username, email, password });
                const data = response.data;
                currentUser = data.user;
                
                // K·∫øt n·ªëi WebSocket v·ªõi token
                connectSocket(data.token);

                // ·∫®n form ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω
                document.querySelector('.auth-container').style.display = 'none';
                document.querySelector('.call-section').style.display = 'block';

                updateStatus(`ƒê√£ ƒëƒÉng k√Ω v√† ƒëƒÉng nh·∫≠p: ${currentUser.username}`);
            } catch (error) {
                alert(error.response?.data?.message || 'L·ªói ƒëƒÉng k√Ω');
            }
        }

        function logout() {
            if (socket) {
                socket.disconnect();
            }
            currentUser = null;
            // X√≥a th√¥ng tin ƒëƒÉng nh·∫≠p kh·ªèi localStorage
            localStorage.removeItem('auth');
            cleanup();

            // Hi·ªÉn th·ªã l·∫°i form ƒëƒÉng nh·∫≠p/ƒëƒÉng k√Ω
            document.querySelector('.auth-container').style.display = 'flex';
            document.querySelector('.call-section').style.display = 'none';

            // Reset c√°c form
            document.getElementById('loginUsername').value = '';
            document.getElementById('loginPassword').value = '';
            document.getElementById('regUsername').value = '';
            document.getElementById('regEmail').value = '';
            document.getElementById('regPassword').value = '';
        }

        function connectSocket(token) {
            // K·∫øt n·ªëi t·ªõi WebSocket server v·ªõi token
            socket = io('http://localhost:60804', {
                query: {
                    token: token
                }
            });

            setupSocketListeners();
            setupLocalStream();
            loadConversations();
        }

        function setupSocketListeners() {
            socket.on('connect', () => {
                console.log('‚úÖ Socket connected successfully', {
                    socketId: socket.id,
                    userId: currentUser?._id,
                    username: currentUser?.username
                });
                updateStatus('ƒê√£ k·∫øt n·ªëi t·ªõi server');
            });

            socket.on('disconnect', () => {
                console.log('‚ùå Socket disconnected');
                updateStatus('M·∫•t k·∫øt n·ªëi t·ªõi server');
                cleanup();
            });

            socket.on('connect_error', (error) => {
                console.error('‚ùå Socket connection error:', error);
                updateStatus('L·ªói k·∫øt n·ªëi: ' + error.message);
            });

            socket.on('incoming_call', async (data) => {
                try {
                    console.log('üìû Incoming call received:', {
                        from: data.from,
                        fromUsername: data.fromUsername,
                        type: data.type,
                        timestamp: new Date().toISOString()
                    });
                    
                    if (!data || !data.from || !data.fromUsername) {
                        throw new Error('D·ªØ li·ªáu cu·ªôc g·ªçi kh√¥ng h·ª£p l·ªá');
                    }

                    // Ki·ªÉm tra xem c√≥ ƒëang trong cu·ªôc g·ªçi kh√°c kh√¥ng
                    if (currentCall) {
                        console.log('‚ùå Reject call - Already in another call', {
                            currentCall,
                            newCall: data.from
                        });
                        socket.emit('call_response', {
                            targetUserId: data.from,
                            accepted: false,
                            reason: 'busy'
                        });
                        return;
                    }

                    // Y√™u c·∫ßu quy·ªÅn th√¥ng b√°o n·∫øu ch∆∞a c√≥
                    if (Notification.permission !== 'granted') {
                        await Notification.requestPermission();
                    }

                    // Hi·ªÉn th·ªã th√¥ng b√°o desktop
                    if (Notification.permission === 'granted') {
                        const notification = new Notification('Cu·ªôc g·ªçi ƒë·∫øn', {
                            body: `${data.fromUsername} ƒëang g·ªçi cho b·∫°n`,
                            requireInteraction: true
                        });
                        
                        notification.onclick = function() {
                            window.focus();
                            this.close();
                        };
                    }

                    // L∆∞u th√¥ng tin cu·ªôc g·ªçi ƒë·∫øn
                    incomingCallData = data;
                    
                    // Hi·ªÉn th·ªã modal v√† ph√°t √¢m b√°o
                    showIncomingCall(data);
                    
                    // T·ª± ƒë·ªông t·ª´ ch·ªëi sau 30 gi√¢y n·∫øu kh√¥ng ph·∫£n h·ªìi
                    setTimeout(() => {
                        if (incomingCallData && incomingCallData.from === data.from) {
                            console.log('‚è∞ Auto rejecting call after timeout', {
                                from: data.from,
                                timestamp: new Date().toISOString()
                            });
                            rejectCall('timeout');
                        }
                    }, 30000);

                } catch (error) {
                    console.error('‚ùå Error handling incoming call:', error);
                    if (data && data.from) {
                        socket.emit('call_response', {
                            targetUserId: data.from,
                            accepted: false,
                            reason: 'error'
                        });
                    }
                }
            });

            socket.on('call_accepted', async (data) => {
                try {
                    console.log('‚úÖ Call accepted:', {
                        from: data.from,
                        username: data.username,
                        timestamp: new Date().toISOString()
                    });
                    hideCallingStatus();
                    updateStatus('Cu·ªôc g·ªçi ƒë∆∞·ª£c ch·∫•p nh·∫≠n');

                    // Ng∆∞·ªùi g·ªçi (caller) t·∫°o peer connection v√† g·ª≠i offer
                    const peerConnection = new RTCPeerConnection(configuration);
                    peerConnections.set(data.from, peerConnection);

                    // Th√™m local stream
                    localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, localStream);
                    });

                    // X·ª≠ l√Ω ICE candidate
                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            console.log('üì§ Sending ICE candidate to:', data.from);
                            socket.emit('ice_candidate', {
                                candidate: event.candidate,
                                targetUserId: data.from
                            });
                        }
                    };

                    // X·ª≠ l√Ω remote stream
                    peerConnection.ontrack = (event) => {
                        console.log('üì• Received remote track from:', data.from);
                        updateRemoteVideo(data.from, event.streams[0]);
                    };

                    // T·∫°o v√† g·ª≠i offer
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    console.log('üì§ Sending offer to:', data.from);
                    socket.emit('offer', {
                        offer,
                        targetUserId: data.from,
                        from: socket.userId
                    });

                    currentCall = {
                        userId: data.from,
                        type: 'outgoing'
                    };
                } catch (error) {
                    console.error('‚ùå Error in call_accepted:', error);
                    updateStatus('L·ªói khi thi·∫øt l·∫≠p cu·ªôc g·ªçi');
                }
            });

            socket.on('call_rejected', (data) => {
                console.log('‚ùå Call rejected:', {
                    from: data.from,
                    reason: data.reason,
                    timestamp: new Date().toISOString()
                });
                hideCallingStatus();
                let message = 'Cu·ªôc g·ªçi b·ªã t·ª´ ch·ªëi';
                
                // Th√™m l√Ω do t·ª´ ch·ªëi n·∫øu c√≥
                if (data.reason) {
                    switch(data.reason) {
                        case 'busy':
                            message += ': Ng∆∞·ªùi d√πng ƒëang b·∫≠n';
                            break;
                        case 'timeout':
                            message += ': Kh√¥ng c√≥ ph·∫£n h·ªìi';
                            break;
                        case 'error':
                            message += ': L·ªói k·∫øt n·ªëi';
                            break;
                        default:
                            message += ': ' + data.reason;
                    }
                }
                
                updateStatus(message);
                cleanup();
            });

            socket.on('call_error', (error) => {
                console.error('‚ùå Call error:', error);
                updateStatus('L·ªói cu·ªôc g·ªçi: ' + error.message);
            });

            async function waitForRemoteDescription(peerConnection) {
                return new Promise((resolve) => {
                    if (peerConnection.remoteDescription) {
                        resolve();
                        return;
                    }
                    const checkInterval = setInterval(() => {
                        if (peerConnection.remoteDescription) {
                            clearInterval(checkInterval);
                            resolve();
                        }
                    }, 100);
                });
            }

            socket.on('ice_candidate', async (data) => {
                try {
                    const peerConnection = peerConnections.get(data.from);
                    if (!peerConnection) {
                        console.error('‚ùå No peer connection found for user:', data.from);
                        return;
                    }

                    // N·∫øu ch∆∞a c√≥ remote description, cache candidate
                    if (!peerConnection.remoteDescription) {
                        console.log('‚è≥ Caching ICE candidate - No remote description yet');
                        if (!peerConnection.cachedCandidates) {
                            peerConnection.cachedCandidates = [];
                        }
                        peerConnection.cachedCandidates.push(data.candidate);
                        return;
                    }

                    // Th√™m candidate n·∫øu tr·∫°ng th√°i cho ph√©p
                    if (data.candidate && ['stable', 'have-remote-offer', 'have-local-offer'].includes(peerConnection.signalingState)) {
                        await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                        console.log('‚úÖ ICE candidate added successfully');
                    }
                } catch (error) {
                    console.error('‚ùå Error handling ICE candidate:', error);
                }
            });

            socket.on('offer', async (data) => {
                try {
                    console.log('üì® Received offer from:', data.from);
                    
                    // Ng∆∞·ªùi nh·∫≠n (callee) t·∫°o peer connection ƒë·ªÉ tr·∫£ l·ªùi
                    const peerConnection = new RTCPeerConnection(configuration);
                    peerConnections.set(data.from, peerConnection);

                    // Th√™m local stream
                    localStream.getTracks().forEach(track => {
                        peerConnection.addTrack(track, localStream);
                    });

                    // X·ª≠ l√Ω ICE candidate
                    peerConnection.onicecandidate = (event) => {
                        if (event.candidate) {
                            console.log('üì§ Sending ICE candidate to:', data.from);
                            socket.emit('ice_candidate', {
                                candidate: event.candidate,
                                targetUserId: data.from
                            });
                        }
                    };

                    // X·ª≠ l√Ω remote stream
                    peerConnection.ontrack = (event) => {
                        console.log('üì• Received remote track from:', data.from);
                        updateRemoteVideo(data.from, event.streams[0]);
                    };

                    // Thi·∫øt l·∫≠p remote description t·ª´ offer nh·∫≠n ƒë∆∞·ª£c
                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.offer));

                    // T·∫°o v√† g·ª≠i answer
                    const answer = await peerConnection.createAnswer();
                    await peerConnection.setLocalDescription(answer);
                    console.log('üì§ Sending answer to:', data.from);
                    socket.emit('answer', {
                        answer,
                        targetUserId: data.from,
                        from: socket.userId
                    });

                    currentCall = {
                        userId: data.from,
                        type: 'incoming'
                    };
                } catch (error) {
                    console.error('‚ùå Error handling offer:', error);
                    socket.emit('call_error', {
                        message: 'L·ªói x·ª≠ l√Ω offer: ' + error.message
                    });
                }
            });

            socket.on('answer', async (data) => {
                try {
                    console.log('üì® Received answer from:', data.from);
                    const peerConnection = peerConnections.get(data.from);
                    
                    if (!peerConnection) {
                        throw new Error('No peer connection found for user: ' + data.from);
                    }

                    await peerConnection.setRemoteDescription(new RTCSessionDescription(data.answer));
                    console.log('‚úÖ Remote description set successfully');

                    // Th√™m c√°c ICE candidate ƒë√£ cache (n·∫øu c√≥)
                    if (peerConnection.cachedCandidates?.length > 0) {
                        console.log('üì§ Adding cached ICE candidates');
                        for (const candidate of peerConnection.cachedCandidates) {
                            await peerConnection.addIceCandidate(new RTCIceCandidate(candidate));
                        }
                        peerConnection.cachedCandidates = [];
                    }
                } catch (error) {
                    console.error('‚ùå Error handling answer:', error);
                }
            });

            socket.on('call_ended', () => {
                console.log('üìû Call ended');
                hideCallingStatus();
                hideIncomingCall();
                updateStatus('Cu·ªôc g·ªçi k·∫øt th√∫c');
                cleanup();
            });
        }

        async function setupLocalStream() {
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                document.getElementById('localVideo').srcObject = localStream;
            } catch (error) {
                console.error('Error accessing media devices:', error);
                updateStatus('L·ªói truy c·∫≠p camera/mic');
            }
        }

        async function setupPeerConnection(targetUserId, isInitiator) {
            const peerConnection = new RTCPeerConnection(configuration);
            console.log('setupPeerConnection targetUserId:', targetUserId, 'isInitiator:', isInitiator);
            
            // L∆∞u k·∫øt n·ªëi
            peerConnections.set(targetUserId, peerConnection);
            
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    socket.emit('ice_candidate', {
                        candidate: event.candidate,
                        targetUserId
                    });
                }
            };

            peerConnection.ontrack = (event) => {
                const remoteVideo = document.createElement('video');
                remoteVideo.srcObject = event.streams[0];
                remoteVideo.autoplay = true;
                remoteVideo.playsInline = true;
                remoteVideo.className = 'remote-video';
                remoteVideo.id = `remote-video-${targetUserId}`;
                document.getElementById('remoteVideos').appendChild(remoteVideo);
            };

            if (isInitiator) {
                try {
                    const offer = await peerConnection.createOffer();
                    await peerConnection.setLocalDescription(offer);
                    socket.emit('offer', {
                        offer,
                        targetUserId,
                        from: socket.userId
                    });
                } catch (error) {
                    console.error('Error creating offer:', error);
                }
            }

            currentCall = targetUserId;
        }

        async function startCall() {
            try {
                const conversationId = document.getElementById('conversationSelect').value;
                if (!conversationId) {
                    alert('Vui l√≤ng ch·ªçn cu·ªôc tr√≤ chuy·ªán');
                    return;
                }

                // G·ª≠i y√™u c·∫ßu g·ªçi ƒë·∫øn server
                socket.emit('call_user', {
                    conversationId,
                    type: 'video' // M·∫∑c ƒë·ªãnh l√† video call
                });

                // Hi·ªÉn th·ªã UI cu·ªôc g·ªçi
                document.getElementById('callControls').style.display = 'none';
                document.getElementById('inCallControls').style.display = 'block';
                
                // B·∫Øt ƒë·∫ßu ph√°t nh·∫°c chu√¥ng
                playRingtone();
                
            } catch (error) {
                console.error('L·ªói khi b·∫Øt ƒë·∫ßu cu·ªôc g·ªçi:', error);
                alert('Kh√¥ng th·ªÉ b·∫Øt ƒë·∫ßu cu·ªôc g·ªçi: ' + error.message);
            }
        }

        function endCall() {
            try {
                console.log('üìû Ending call');
                
                // G·ª≠i t√≠n hi·ªáu k·∫øt th√∫c cu·ªôc g·ªçi ƒë·∫øn server
                if (currentCall?.userId) {
                    socket.emit('end_call', {
                        targetUserId: currentCall.userId
                    });
                }

                // D·ªçn d·∫πp
                cleanup();
                
                console.log('‚úÖ Call ended successfully');
            } catch (error) {
                console.error('‚ùå Error ending call:', error);
            }
        }

        function cleanup() {
            try {
                console.log('üßπ Cleaning up call resources');
                
                // D·ªçn d·∫πp c√°c k·∫øt n·ªëi peer
                peerConnections.forEach((peerConnection, userId) => {
                    console.log(`Closing peer connection for user: ${userId}`);
                    peerConnection.close();
                    peerConnections.delete(userId);
                });

                // X√≥a t·∫•t c·∫£ remote videos
                const remoteVideosContainer = document.getElementById('remoteVideos');
                while (remoteVideosContainer.firstChild) {
                    remoteVideosContainer.removeChild(remoteVideosContainer.firstChild);
                }

                // Reset c√°c bi·∫øn
                currentCall = null;
                incomingCallData = null;

                // Reset UI
                document.getElementById('callControls').style.display = 'block';
                document.getElementById('inCallControls').style.display = 'none';
                hideCallingStatus();
                hideIncomingCall();
                stopRingtone();

                console.log('‚úÖ Cleanup completed');
            } catch (error) {
                console.error('‚ùå Error during cleanup:', error);
            }
        }

        // Th√™m h√†m ƒë·ªÉ qu·∫£n l√Ω video elements
        function updateRemoteVideo(userId, stream) {
            try {
                console.log(`Updating remote video for user: ${userId}`);
                
                // X√≥a video c≈© n·∫øu c√≥
                const existingVideo = document.getElementById(`remote-video-${userId}`);
                if (existingVideo) {
                    existingVideo.remove();
                }

                // T·∫°o video m·ªõi
                const remoteVideo = document.createElement('video');
                remoteVideo.srcObject = stream;
                remoteVideo.autoplay = true;
                remoteVideo.playsInline = true;
                remoteVideo.className = 'remote-video';
                remoteVideo.id = `remote-video-${userId}`;
                document.getElementById('remoteVideos').appendChild(remoteVideo);

                console.log('‚úÖ Remote video updated successfully');
            } catch (error) {
                console.error('‚ùå Error updating remote video:', error);
            }
        }

        function toggleAudio() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                audioTrack.enabled = !audioTrack.enabled;
                document.getElementById('audioBtn').textContent = 
                    audioTrack.enabled ? 'T·∫Øt mic' : 'B·∫≠t mic';
            }
        }

        function toggleVideo() {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                videoTrack.enabled = !videoTrack.enabled;
                document.getElementById('videoBtn').textContent = 
                    videoTrack.enabled ? 'T·∫Øt camera' : 'B·∫≠t camera';
            }
        }

        function updateStatus(message) {
            document.getElementById('connectionStatus').textContent = message;
        }

        function showIncomingCall(data) {
            try {
                console.log('üì± Showing incoming call UI:', data);
                incomingCallData = data; // L∆∞u data ngay khi hi·ªÉn th·ªã
                const callerName = document.getElementById('callerName');
                callerName.textContent = data.fromUsername || data.from;
                const modal = document.getElementById('incomingCallModal');
                modal.style.display = 'block';
                playRingtone();
            } catch (error) {
                console.error('‚ùå Error showing incoming call:', error);
            }
        }

        function hideIncomingCall() {
            try {
                const modal = document.getElementById('incomingCallModal');
                modal.style.display = 'none';
                stopRingtone();
                // KH√îNG x√≥a incomingCallData ·ªü ƒë√¢y v√¨ c√≤n c·∫ßn d√πng cho vi·ªác thi·∫øt l·∫≠p k·∫øt n·ªëi
            } catch (error) {
                console.error('‚ùå Error hiding incoming call:', error);
            }
        }

        function showCallingStatus() {
            const status = document.getElementById('callingStatus');
            status.style.display = 'block';
        }

        function hideCallingStatus() {
            const status = document.getElementById('callingStatus');
            status.style.display = 'none';
        }

        async function acceptCall() {
            try {
                console.log('Accepting call with data:', incomingCallData);
                
                if (!incomingCallData) {
                    console.error('‚ùå No incoming call data available');
                    updateStatus('L·ªói: Kh√¥ng c√≥ th√¥ng tin cu·ªôc g·ªçi');
                    return;
                }
                
                hideIncomingCall();
                updateStatus('ƒêang k·∫øt n·ªëi cu·ªôc g·ªçi...');
                
                // G·ª≠i ph·∫£n h·ªìi ch·∫•p nh·∫≠n cu·ªôc g·ªçi
                console.log('üì§ Sending call_response:', {
                    targetUserId: incomingCallData.from,
                    accepted: true,
                    timestamp: new Date().toISOString()
                });
                
                socket.emit('call_response', {
                    targetUserId: incomingCallData.from,
                    accepted: true
                });
                
                // KH√îNG t·∫°o peer connection ·ªü ƒë√¢y
                // Ch·ªù nh·∫≠n offer t·ª´ ng∆∞·ªùi g·ªçi
                
            } catch (error) {
                console.error('‚ùå Error in acceptCall:', error);
                updateStatus('L·ªói khi ch·∫•p nh·∫≠n cu·ªôc g·ªçi');
            }
        }

        function rejectCall(reason = 'rejected') {
            try {
                console.log('Rejecting call:', {
                    incomingCallData,
                    reason,
                    timestamp: new Date().toISOString()
                });
                
                if (!incomingCallData) {
                    console.error('‚ùå No incoming call data available');
                    return;
                }
                
                socket.emit('call_response', {
                    targetUserId: incomingCallData.from,
                    accepted: false,
                    reason: reason
                });
                
                hideIncomingCall();
                updateStatus('ƒê√£ t·ª´ ch·ªëi cu·ªôc g·ªçi');
                cleanup();
            } catch (error) {
                console.error('‚ùå Error in rejectCall:', error);
            }
        }

        // Th√™m √¢m thanh th√¥ng b√°o
        let ringtone;
        function playRingtone() {
            ringtone = new Audio('https://assets.mixkit.co/active_storage/sfx/2912/2912-preview.mp3');
            ringtone.loop = true;
            ringtone.play().catch(e => console.log('Kh√¥ng th·ªÉ ph√°t nh·∫°c chu√¥ng:', e));
        }

        function stopRingtone() {
            if (ringtone) {
                ringtone.pause();
                ringtone.currentTime = 0;
            }
        }

        // Th√™m h√†m ki·ªÉm tra ƒëƒÉng nh·∫≠p khi load trang
        function checkAuth() {
            const auth = localStorage.getItem('auth');
            if (auth) {
                const { user, token } = JSON.parse(auth);
                currentUser = user;
                connectSocket(token);
                document.querySelector('.auth-container').style.display = 'none';
                document.querySelector('.call-section').style.display = 'block';
                updateStatus(`ƒê√£ ƒëƒÉng nh·∫≠p: ${currentUser.username}`);
            }
        }

        // Th√™m h√†m load conversations
        async function loadConversations() {
            try {
                const auth = localStorage.getItem('auth');
                if (!auth) {
                    throw new Error('Ch∆∞a ƒëƒÉng nh·∫≠p');
                }

                const { token } = JSON.parse(auth);
                const response = await axios.get('http://localhost:60804/api/conversations', {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });

                const data = response.data;
                console.log('Danh s√°ch conversations:', data.conversations);
                
                const select = document.getElementById('conversationSelect');
                if (!select) {
                    console.error('Kh√¥ng t√¨m th·∫•y element conversationSelect');
                    return;
                }
                
                // X√≥a c√°c option c≈©
                select.innerHTML = '<option value="">Ch·ªçn cu·ªôc tr√≤ chuy·ªán</option>';
                
                // Th√™m c√°c option m·ªõi
                if (data.conversations && Array.isArray(data.conversations)) {
                    data.conversations.forEach(conv => {
                        if (!conv || !conv.conversationId) return; // S·ª≠a t·ª´ _id th√†nh conversationId
                        
                        const option = document.createElement('option');
                        option.value = conv.conversationId; // S·ª≠a t·ª´ _id th√†nh conversationId
                        
                        // Ki·ªÉm tra v√† x·ª≠ l√Ω t√™n hi·ªÉn th·ªã
                        let displayName = '';
                        if (conv.type === 'private') {
                            // V·ªõi private chat, hi·ªÉn th·ªã t√™n ng∆∞·ªùi d√πng kh√°c
                            displayName = conv.conversationId || 'Chat ri√™ng';
                        } else {
                            // V·ªõi group chat, hi·ªÉn th·ªã t√™n nh√≥m v√† s·ªë th√†nh vi√™n
                            displayName = conv.name ? 
                                `Nh√≥m: ${conv.name} (${conv.participants?.length || 0} th√†nh vi√™n)` : 
                                `Nh√≥m chat (${conv.participants?.length || 0} th√†nh vi√™n)`;
                        }
                        
                        option.textContent = displayName;
                        select.appendChild(option);
                    });

                    // Log s·ªë l∆∞·ª£ng options ƒë√£ th√™m
                    console.log(`ƒê√£ th√™m ${select.options.length - 1} cu·ªôc tr√≤ chuy·ªán v√†o combobox`);
                } else {
                    console.warn('Kh√¥ng c√≥ d·ªØ li·ªáu conversations ho·∫∑c ƒë·ªãnh d·∫°ng kh√¥ng ƒë√∫ng');
                }

                // Ki·ªÉm tra v√† log tr·∫°ng th√°i c·ªßa select
                console.log('Tr·∫°ng th√°i combobox:', {
                    visible: select.offsetParent !== null,
                    width: select.offsetWidth,
                    height: select.offsetHeight,
                    options: select.options.length
                });
            } catch (error) {
                console.error('L·ªói t·∫£i conversations:', error);
                alert(error.response?.data?.message || error.message);
            }
        }
    </script>
</body>
</html> 